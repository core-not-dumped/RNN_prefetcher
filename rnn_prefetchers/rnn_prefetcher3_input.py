# -*- coding: utf-8 -*-
"""rnn_prefetcher3_input.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vQsnjkPd6s01aQsoQXpVEnlGOZpUovse
"""

from google.colab import drive
drive.mount('/content/drive')

import numpy as np
import tensorflow as tf
from tqdm import tqdm

#f = open("473.astar-s0.txt", 'r')
f = open('/content/drive/MyDrive/Colab Notebooks/dataset/473.astar-s0.txt', 'r')

load_address = list()

f.seek(0, 0)
while True:
  line = f.readline()
  if not line: break
  split_line = line.split(', ')
  load_address.append(split_line[2])

for i in range(len(load_address)):
  load_address[i] = int(load_address[i], 16)//64

print("\nload_address example: ")
print(load_address[:100])
print(len(load_address))

offset_dic = dict()
for i in range(len(load_address)):
  if i == 100000:
    print(offset_dic)
    break
  load = load_address[i] >> 10
  if load in offset_dic:
    offset_dic[load].append(load_address[i] % (1 << 10))
  else:
    offset_dic[load] = [load_address[i] % (1 << 10)]

seq_length = 3
output_length = 3

offset_address = np.array(list(offset_dic.keys()))

print(offset_address)
print(offset_address.shape)
print(offset_address[1])

def address_to_binary(a, l):
  binary_int = list()
  for i in range(l):
    binary_int.append(a%2)
    a = a//2
  return binary_int

weight_lean = 0.5
l = 33
scale = 0.1
address_binary_input = list()
address = list()
rnn_input = list()
multi_output = list()
categorical_multi_output = list()

for i in tqdm(range(len(offset_address))):
  offset_list = offset_dic[offset_address[i]]
  if len(offset_list) < seq_length:
    continue

  for j in [0] + list(range(1, len(offset_list) - seq_length - output_length + 1)):
    address_binary_input.append(address_to_binary(offset_address[i], l))
    rnn_input.append(offset_list[j:j+seq_length])
    if len(offset_list) < seq_length + output_length:
      multi_output = offset_list[j+seq_length:]
    else:
      multi_output = offset_list[j+seq_length:j+seq_length+output_length]

    tmp = [0 for k in range(1024)]
    for k in range(len(multi_output)):
      tmp[multi_output[k]] = round(1 - weight_lean * k/output_length,2)
    categorical_multi_output.append(tmp)

address_binary_input = np.array(address_binary_input)
rnn_input = np.array(rnn_input)
categorical_multi_output = np.array(categorical_multi_output)

print(f'{address_binary_input.shape}')
print(f'{rnn_input.shape}')
print(f'{categorical_multi_output.shape}')

# shuffle_data
idx = np.arange(address_binary_input.shape[0])
np.random.shuffle(idx)

address_binary_input = address_binary_input[idx]
rnn_input = rnn_input[idx]
categorical_multi_output = categorical_multi_output[idx]

